## AgeOfWarPython

Учебный проект «Age of War» на Python с использованием библиотеки `SpritePro`.
https://igroutka.ru/flesh-igry/28216-age-of-war.html

![Uploading image.png…]()

Цель проекта — показать понятную, масштабируемую архитектуру (как в «больших» играх), но в простом 2D-стеке: **Scene → Systems → Entities**, и глобальные события через **EventBus (встроенный в SpritePro)**.

## Содержание
- [Быстрый старт](#быстрый-старт)
- [Что уже есть в каркасе](#что-уже-есть-в-каркасе)
- [Структура проекта](#структура-проекта)
- [Архитектура](#архитектура)
  - [Сцены (Scene)](#сцены-scene)
  - [Системы (Systems)](#системы-systems)
  - [Сущности (Entities)](#сущности-entities)
  - [Доменные данные (Domain)](#доменные-данные-domain)
  - [Событийный автобус (EventBus)](#событийный-автобус-eventbus)
- [Как добавлять](#как-добавлять)
  - [Новый ассет и новый путь](#новый-ассет-и-новый-путь)
  - [Новая сущность](#новая-сущность)
  - [Новая система](#новая-система)
  - [Новая сцена](#новая-сцена)
- [Полный пример фичи от и до](#полный-пример-фичи-от-и-до)
- [Список фич и задач](#список-фич-и-задач)
- [Примеры (паттерны)](#примеры-паттерны)

## Быстрый старт

### Требования
- Python 3.10+ (можно 3.8+, если у вас так настроено окружение)
- Windows 10/11

### Установка зависимостей

```bash
pip install -r requirements.txt
```

### Запуск

```bash
python main.py
```

## Что уже есть в каркасе
- **2 сцены**: `MenuScene` и `GameScene`
- **Глобальные события** через встроенный `s.events` (SpritePro EventBus)
- **Каркасные сущности**: `Base`, `Unit`, `Projectile` (пока без полной боёвки)
- **Каркасные системы**: `EconomySystem`, `SpawnSystem`, `BattleSystem`, `UISystem`
- Проект запускается **без обязательных картинок**: сущности рисуются примитивами (`Sprite` с пустым путём изображения)

## Структура проекта

Главное правило: **код игры живёт в пакете `game/`**, а `main.py` остаётся тонкой точкой входа.

- `main.py` — инициализация окна SpritePro и старт первой сцены (`MenuScene`)
- `requirements.txt` — зависимости для установки через pip
- `README.md` — документация по проекту
- `TASKS.md` — фичи и таски для команды
- `EXAMPLES.md` — дополнительные примеры паттернов и заготовок

Пакет игры:
- `config.py` — настройки (окно/FPS/громкости)
- `game/paths.py` — **единый** источник путей к папкам ассетов
- `game/global_events.py` — список глобальных событий проекта (имена + payload)
- `game/scenes/` — сцены (`MenuScene`, `GameScene`)
- `game/systems/` — системы (обновляются сценой каждый кадр)
- `game/entities/` — сущности (обёртки вокруг `SpritePro` спрайтов + состояние)
- `game/domain/` — доменная логика/данные (по возможности без SpritePro)

## Архитектура

### Сцены (Scene)
Сцена отвечает за композицию: **создать мир**, **создать системы**, **обновлять системы каждый кадр**.

Где смотреть:
- `game/scenes/menu_scene.py`
- `game/scenes/game_scene.py`

### Системы (Systems)
**Система** — это объект, который обслуживает один аспект игры и обновляется сценой каждый кадр.

Минимальный контракт системы (в учебном проекте):
- `on_enter()` — инициализация (подписки на события, создание UI)
- `update(dt)` — логика кадра
- `on_exit()` — отписки/очистка

Где смотреть:
- `game/systems/system.py`
- `game/systems/economy_system.py` (пример «реальной» логики + EventBus)
- `game/systems/spawn_system.py` (пример реакции на событие)

### Сущности (Entities)
Сущность — это «объект игры» (юнит/база/снаряд), который содержит:
- визуальное представление (обычно `SpritePro.Sprite`)
- игровое состояние (hp/фракция/статы)

Где смотреть:
- `game/entities/entity.py`
- `game/entities/base.py`
- `game/entities/unit.py`
- `game/entities/projectile.py`

### Доменные данные (Domain)
Домен — это «правила игры» и данные, которые желательно держать отдельно от рендера/ввода.

Примеры:
- `Faction`, `UnitType` — перечисления
- `EconomyModel` — золото/доход, проверка трат
- `UnitStats`/`BaseStats` — характеристики

Где смотреть:
- `game/domain/enums.py`
- `game/domain/economy.py`
- `game/domain/stats.py`

### Событийный автобус (EventBus)
SpritePro уже содержит EventBus: `s.events`. Он позволяет системам и механикам **общаться через события**, не связываясь напрямую друг с другом.

Принцип:
- Система A делает `s.events.send("some.event", data=payload)`
- Система B делает `s.events.connect("some.event", handler)` и обязательно `disconnect` в `on_exit()`

Где смотреть:
- `game/global_events.py` (единый список имён событий проекта)

## Как добавлять

### Новый ассет и новый путь
Правило: **новую папку ассетов — сначала в `game/paths.py`**, потом используем в коде.

1) Создайте папку, например:
- `assets/ui/`

2) Добавьте путь в `game/paths.py` (в `Paths`):

```python
@dataclass(frozen=True)
class Paths:
    assets: str = "assets"
    images: str = "assets/images"
    audio: str = "assets/audio"
    ui: str = "assets/ui"
```

3) Используйте `PATHS.ui` в коде (не пишите строку `"assets/ui"` по проекту).

Почему так лучше:
- проект переезжает/меняет структуру — правим одно место
- меньше опечаток и «разных вариантов» путей

### Новая сущность
1) Создайте файл в `game/entities/`, например `tower.py`
2) Наследуйтесь от `Entity` или используйте его как основу
3) Добавьте фабрику `create(scene, ...)` — чтобы создание было единообразным
4) Подключите сущность в сцене или (лучше) в системе

Мини-ориентир:
- сущность хранит `sprite` + состояние (`hp`, `faction`, `stats`...)
- изменения состояния делайте методами (`apply_damage`, `destroy`, ...)

### Новая система
1) Создайте файл в `game/systems/`, например `projectile_system.py`
2) Реализуйте `on_enter/on_exit/update`
3) Подпишитесь на события в `on_enter`, отписывайтесь в `on_exit`
4) Добавьте систему в список `GameScene.systems`

Рекомендация: **1 система = 1 ответственность** (экономика/спавн/бой/UI).

### Новая сцена
В этом учебном проекте сцен должно быть мало:
- `MenuScene` — меню/настройки/старт
- `GameScene` — игра + HUD

Если всё-таки нужна новая сцена:
1) создайте файл в `game/scenes/`
2) унаследуйтесь от `s.Scene`
3) переход делайте через `s.set_scene(NewScene())`

## Полный пример фичи от и до
Пример фичи: **кнопка “Spawn Unit” в HUD, которая спавнит юнита игрока**.

Цель: сделать фичу так, чтобы она была расширяемой и не превращала `GameScene.update()` в свалку.

### 1) Определяем событие
Событие (и payload) должны жить рядом с той подсистемой, где они “естественно” используются.
В каркасе уже есть:
- `GameEvents.UNIT_SPAWN_REQUESTED`
- `SpawnRequested` в `game/global_events.py`

### 2) Обработчик в системе
`SpawnSystem` подписывается на `GameEvents.UNIT_SPAWN_REQUESTED` и создаёт `Unit`.
Важно: UI **не** создаёт юнита напрямую.

### 3) UI-кнопка в `UISystem`
Правильное место: `game/systems/ui_system.py`, метод `on_enter()`.
Обработчик `on_click` должен эмитить событие:

```python
def on_click_spawn_player() -> None:
    self._events.send(GameEvents.UNIT_SPAWN_REQUESTED, data=SpawnRequested(faction=Faction.PLAYER))
```

### 4) Подключаем в `GameScene`
Убедитесь, что `UISystem` и `SpawnSystem` оба присутствуют в `GameScene.systems`.

### 5) Напоминания
- Если фиче нужен новый ассет (иконка/фон): **сначала** добавьте путь в `game/paths.py`.
- Если фича затрагивает экономику: UI не должен менять золото напрямую — лучше события/методы доменной модели.
- Если фича большая: разбейте её на таски в `TASKS.md`.

## Список фич и задач
Смотрите файл `TASKS.md`.

## Примеры (паттерны)
Смотрите файл `EXAMPLES.md`.
